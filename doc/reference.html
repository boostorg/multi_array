<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!--
== Copyright 2002 The Trustees of Indiana University.

== Distributed under the Boost Software License, Version 1.0.
== (See accompanying file LICENSE_1_0.txt or copy at
== http://www.boost.org/LICENSE_1_0.txt)

==  Boost.MultiArray Library
==  Authors: Ronald Garcia
==           Jeremy Siek
==           Andrew Lumsdaine
==  See http://www.boost.org/libs/multi_array for documentation.
-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Boost.MultiArray Reference Manual</title>
<link rel="stylesheet" href="multi_array.css" type="text/css" />
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
</head>
<body link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="article" title="Boost.MultiArray Reference Manual">
<div class="titlepage">
<div>
<div>
<h1 class="title">
<a name="idp2304"><img src="../../../boost.png" alt="C++ Boost"
width="277" height="86" align="middle" /></a>
<br />Boost.MultiArray Reference Manual
</h1>
</div>
<div>
<div class="author">
<h3 class="author"><span class="firstname">Ronald</span>
<span class="surname">Garcia</span></h3>
<div class="affiliation"><span class="orgname">Indiana University<br /></span>
<span class="orgdiv">Open Systems Lab<br></span></div>
</div>
</div>
<div>
<p class="copyright">Copyright © 2002 The Trustees of Indiana University</p>
</div>
</div>
<hr />
</div>
<div class="toc">
<p><b>Table of Contents</b></p>
<dl>
<dt><span class="sect1"><a href="#synopsis">Library Synopsis</a></span></dt>
<dt><span class="sect1"><a href="#MultiArray">MultiArray
Concept</a></span></dt>
<dd>
<dl>
<dt><span class="sect2"><a href="#idp18427760">Notation</a></span></dt>
<dt><span class="sect2"><a href="#idp18446208">Associated
Types</a></span></dt>
<dt><span class="sect2"><a href="#idp18501744">Valid
expressions</a></span></dt>
<dt><span class="sect2"><a href="#idp18588736">Complexity
guarantees</a></span></dt>
<dt><span class="sect2"><a href="#idp18591264">Invariants</a></span></dt>
<dt><span class="sect2"><a href="#view_types">Associated Types for
Views</a></span></dt>
<dt><span class="sect2"><a href="#idp18737792">Models</a></span></dt>
</dl>
</dd>
<dt><span class="sect1"><a href="#array_types">Array
Components</a></span></dt>
<dd>
<dl>
<dt><span class="sect2"><a href="#multi_array_class"><tt class="literal"
>multi_array</tt></a></span></dt>
<dt><span class="sect2"><a href="#multi_array_ref"><tt class="literal"
>multi_array_ref</tt></a></span></dt>
<dt><span class="sect2"><a href="#const_multi_array_ref"><tt class="literal"
>const_multi_array_ref</tt></a></span></dt>
</dl>
</dd>
<dt><span class="sect1"><a href="#auxiliary">Auxiliary
Components</a></span></dt>
<dd>
<dl>
<dt><span class="sect2"><a href="#multi_array_types"><tt class="literal"
>multi_array_types</tt></a></span></dt>
<dt><span class="sect2"><a href="#extent_range"><tt class="classname"
>extent_range</tt></a></span></dt>
<dt><span class="sect2"><a href="#extent_gen"><tt class="classname"
>extent_gen</tt></a></span></dt>
<dt><span class="sect2"><a href="#idp19487120">Global
Objects</a></span></dt>
<dt><span class="sect2"><a href="#generators">View and SubArray
Generators</a></span></dt>
<dt><span class="sect2"><a href="#memory_layout">Memory Layout
Specifiers</a></span></dt>
<dt><span class="sect2"><a href="#range_checking">Range
Checking</a></span></dt>
</dl>
</dd>
</dl>
</div>
<p>Boost.MultiArray is composed of several components.  The
<strong>MultiArray</strong> concept defines a generic interface to
multidimensional containers.  <tt class="literal">multi_array</tt>
is a general purpose container class that models
<strong>MultiArray</strong>.  <tt class="literal">multi_array_ref</tt> and
<tt class="literal">const_multi_array_ref</tt> are adapter classes.  Using
them, you can manipulate any block of contiguous data as though it were a
<tt class="literal">multi_array</tt>.  <tt class="literal"
>const_multi_array_ref</tt> differs from <tt class="literal"
>multi_array_ref</tt> in that its elements cannot be modified through its
interface.  Finally, several auxiliary classes are used to create and
specialize arrays and some global objects are defined as part of the library
interface.</p>
<div class="sect1" title="Library Synopsis">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="synopsis"></a>Library
Synopsis</h2>
</div>
</div>
</div>
<p>To use Boost.MultiArray, you must include the header <tt class="filename"
>boost/multi_array.hpp</tt> in your source.  This file brings the following
declarations into scope:</p>
<pre class="programlisting">
namespace boost { namespace multi_array_types {

    typedef *unspecified* index;
    typedef *unspecified* size_type;
    typedef *unspecified* difference_type;
    typedef *unspecified* index_range;
    typedef *unspecified* extent_range;
    typedef *unspecified* index_gen;
    typedef *unspecified* extent_gen;
}}

namespace boost {

    template &lt;
        typename ValueType
      , std::size_t NumDims
      , typename Allocator = std::allocator&lt;ValueType&gt;
    &gt; class multi_array;

    template &lt;typename ValueType, std::size_t NumDims&gt;
    class multi_array_ref;

    template &lt;typename ValueType, std::size_t NumDims&gt;
    class const_multi_array_ref;

    multi_array_types::extent_gen extents;
    multi_array_types::index_gen  indices;

    template &lt;typename Array, int N&gt; class subarray_gen;
    template &lt;typename Array, int N&gt; class const_subarray_gen;
    template &lt;typename Array, int N&gt; class array_view_gen;
    template &lt;typename Array, int N&gt; class const_array_view_gen;

    class c_storage_order; 
    class fortran_storage_order;
    template &lt;std::size_t NumDims&gt; class general_storage_order;
}
</pre>
</div>
<div class="sect1" title="MultiArray Concept">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="MultiArray"></a>MultiArray
Concept</h2>
</div>
</div>
</div>
<p>The <strong>MultiArray</strong> concept defines an interface to
hierarchically nested containers.  It specifies operations for accessing
elements, traversing containers, and creating views of array
data.  <strong>MultiArray</strong> defines a flexible memory model that
accomodates a variety of data layouts.</p>
<p>At each level (or dimension) of a <strong>MultiArray</strong>'s container
hierarchy lie a set of ordered containers, each of which contains the same
number and type of values.  The depth of this container hierarchy is the
<strong>MultiArray</strong>'s <span class="emphasis"><em
>dimensionality</em></span>.  <strong>MultiArray</strong> is recursively
defined; the containers at each level of the container hierarchy model
<strong>MultiArray</strong> as well.  While each dimension of a <strong
>MultiArray</strong> has its own size, the list of sizes for all dimensions
defines the <span class="emphasis"><em>shape</em></span> of the entire
<strong>MultiArray</strong>.  At the base of this hierarchy lie 1-dimensional
<strong>MultiArrays</strong>.  Their values are the contained objects of
interest and not part of the container hierarchy.  These are the
<strong>MultiArray</strong>'s elements.</p>
<p>Like other container concepts, <strong>MultiArray</strong> exports
iterators to traverse its values.  In addition, values can be addressed
directly using the familiar bracket notation.</p>
<p><strong>MultiArray</strong> also specifies routines for creating
specialized views.  A <span class="emphasis"><em>view</em></span> lets you
treat a subset of the underlying elements in a <strong>MultiArray</strong> as
though it were a separate <strong>MultiArray</strong>.  Since a view refers to
the same underlying elements, changes made to a view's elements will be
reflected in the original <strong>MultiArray</strong>.  For example, given a
3-dimensional "cube" of elements, a 2-dimensional slice can be viewed as if it
were an independent <strong>MultiArray</strong>.</p>
<p>Views are created using <tt class="literal">index_gen</tt> and
<tt class="literal">index_range</tt> objects.  <tt class="literal"
>index_range</tt>s denote elements from a certain dimension that are to be
included in a view.  <tt class="literal">index_gen</tt> aggregates range data
and performs bookkeeping to determine the view type to be returned.</p>
<p><strong>MultiArray</strong>'s <tt class="literal">operator[]</tt> must be
passed the result of <tt class="literal">N</tt> chained calls to 
<tt class="literal">index_gen::operator[]</tt>, i.e.</p>
<pre class="programlisting">
    indices[a0][a1]...[aN];
</pre>
<p>where <tt class="literal">N</tt> is the <strong>MultiArray</strong>'s
dimensionality and <tt class="literal">indices</tt> an object of type
<tt class="literal">index_gen</tt>.</p>
<p>The view type is dependent upon the number of degenerate dimensions
specified to <tt>index_gen</tt>.  A degenerate dimension occurs when a
single-index is specified to <tt class="literal">index_gen</tt> for a certain
dimension.  For example, if <tt class="literal">indices</tt> is an object of
type <tt class="literal">index_gen</tt>, then the following example:</p>
<pre class="programlisting">
    indices[index_range(0, 5)][2][index_range(0, 4)];
</pre>
<p>has a degenerate second dimension.  The view generated from the above
specification will have 2 dimensions with shape <tt class="literal">5 x
4</tt>.  If the "<tt class="literal">2</tt>" above were replaced with another
<tt class="literal">index_range</tt> object, for example:</p>
<pre class="programlisting">
    indices[index_range(0, 5)][index_range(0, 2)][index_range(0, 4)];
</pre>
<p>then the view would have 3 dimensions.</p>
<p><strong>MultiArray</strong> exports information regarding the memory layout
of its contained elements. Its memory model for elements is completely defined
by 4 properties: the origin, shape, index bases, and strides.  The origin is
the address in memory of the element accessed as
<tt class="literal">a[0][0]...[0]</tt>, where <tt class="literal">a</tt> is a
<strong>MultiArray</strong>. The shape is a list of numbers specifying the
size of containers at each dimension.  For example, the first extent is the
size of the outermost container, the second extent is the size of its
subcontainers, and so on.  The index bases are a list of signed values
specifying the index of the first value in a container.  All containers at the
same dimension share the same index base.  Note that since positive index
bases are possible, the origin need not exist in order to determine the
location in memory of the <strong>MultiArray</strong>'s elements.</p>
<p>The strides determine how index values are mapped to memory offsets.  They
accomodate a number of possible element layouts.  For example, the elements of
a 2 dimensional array can be stored by row (i.e., the elements of each row are
stored contiguously) or by column (i.e., the elements of each column are
stored contiguously).</p>
<p>Two concept checking classes for the <strong>MultiArray</strong> concepts
(<tt class="literal">ConstMultiArrayConcept</tt> and
<tt class="literal">MutableMultiArrayConcept</tt>) are in the namespace
<tt class="literal">boost::multi_array_concepts</tt> in
<tt class="literal">&lt;boost/multi_array/concept_checks.hpp&gt;</tt>.</p>
<div class="sect2" title="Notation">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="idp18427760"></a>Notation</h3>
</div>
</div>
</div>
<p>What follows are the descriptions of symbols that will be used to describe
the <strong>MultiArray</strong> interface.</p>
<div class="table"><a name="idp18428768"></a>
<p class="title"><strong>Table 1. Notation</strong></p>
<div class="table-contents">
<table summary="Notation" border="1">
<colgroup><col /><col /></colgroup>
<tbody>
<tr>
<td><tt class="literal">A</tt></td>
<td>A type that is a model of <strong>MultiArray</strong></td>
</tr>
<tr>
<td><tt class="literal">a,b</tt></td>
<td>Objects of type <code class="literal">A</code></td>
</tr>
<tr>
<td><code class="literal">NumDims</code></td>
<td>The numeric dimension parameter associated with
<tt class="literal">A</tt>.</td>
</tr>
<tr>
<td><code class="literal">Dims</code></td>
<td>Some numeric dimension parameter such that 
<tt class="literal">0&lt;Dims&lt;NumDims</tt>.</td>
</tr>
<tr>
<td><tt class="literal">indices</tt></td>
<td>An object created by some number of chained calls to
<tt class="literal">index_gen::operator[](index_range)</tt>.</td>
</tr>
<tr>
<td><tt class="literal">index_list</tt></td>
<td>An object whose type models <a class="ulink"
href="../../utility/Collection.html" target="_top"
><strong>Collection</strong></a></td>
</tr>
<tr>
<td><tt class="literal">idx</tt></td>
<td>A signed integral value.</td>
</tr>
<tr>
<td><code class="literal">tmp</code></td>
<td>An object of type
<tt class="literal">boost::array&lt;index,NumDims&gt;</tt></td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break" />
</div>
<div class="sect2" title="Associated Types">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="idp18446208"></a>Associated Types</h3>
</div>
</div>
</div>
<p></p>
<div class="table"><a name="idp18447104"></a>
<p class="title"><strong>Table 2. Associated Types</strong></p>
<div class="table-contents"><table summary="Associated Types" border="1">
<colgroup><col /><col /></colgroup>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><tt class="literal">value_type</tt></td>
<td>This is the value type of the container.  If <tt class="literal">NumDims
== 1</tt>, then this is <tt class="literal">element</tt>.  Otherwise, this is
the value type of the immediately nested containers.</td>
</tr>
<tr>
<td><tt class="literal">reference</tt></td>
<td>This is the reference type of the contained value.  If
<tt class="literal">NumDims == 1</tt>, then this is 
<tt class="literal">element&amp;</tt>.  Otherwise, this is the same type as
<tt class="literal">template subarray&lt;NumDims-1&gt;::type</tt>.</td>
</tr>
<tr>
<td><tt class="literal">const_reference</tt></td>
<td>This is the const reference type of the contained value.  If
<tt class="literal">NumDims == 1</tt>, then this is <tt
class="literal">element const&amp;</tt>.  Otherwise, this is the same type as
<tt class="literal">template const_subarray&lt;NumDims-1&gt;::type</tt>.
</td>
</tr>
<tr>
<td><tt class="literal">size_type</tt></td>
<td>This is an unsigned integral type.  It is primarily used to specify array
shape.</td>
</tr>
<tr>
<td><tt class="literal">difference_type</tt></td>
<td>This is a signed integral type used to represent the distance between two
iterators.  It is the same type as <tt class="literal"
>std::iterator_traits&lt;iterator&gt;::difference_type</tt>.</td>
</tr>
<tr>
<td><tt class="literal">iterator</tt></td>
<td>This is an iterator over the values of <tt class="literal">A</tt>.  If
<tt class="literal">NumDims == 1</tt>, then it models <a class="ulink" href=
"http://www.rrsd.com/software_development/stl/stl/RandomAccessIterator.html"
target="_top"><tt class="literal">Random Access Iterator</tt></a>.  Otherwise,
it models <a class="ulink"
href="./iterator_categories.html#concept_RandomAccessTraversalIterator"
target="_top"><tt class="literal">Random Access Traversal Iterator</tt></a>,
<a class="ulink" href="./iterator_categories.html#concept_ReadableIterator"
target="_top"><tt class="literal">Readable Iterator</tt></a>,
<a class="ulink" href="./iterator_categories.html#concept_WritableIterator"
target="_top"><tt class="literal">Writable Iterator</tt></a>, and 
<a class="ulink" href="../../../doc/html/OutputIterator.html"
target="_top"><tt class="literal">Output Iterator</tt></a>.</td>
</tr>
<tr>
<td><tt class="literal">const_iterator</tt></td>
<td>This is the const iterator over the values of
<tt class="literal">A</tt>.</td>
</tr>
<tr>
<td><tt class="literal">reverse_iterator</tt></td>
<td>This is the reversed iterator, used to iterate backwards over the values
of <tt class="literal">A</tt>.</td>
</tr>
<tr>
<td><tt class="literal">const_reverse_iterator</tt></td>
<td>This is the reversed const iterator, used to iterate backwards over
immutable views of the values of <tt class="literal">A</tt>.</td>
</tr>
<tr>
<td><tt class="literal">element</tt></td>
<td>This is the type of objects stored at the base of the hierarchy of
<strong>MultiArrays</strong>.  It is the same as
<tt class="literal">template subarray&lt;1&gt;::value_type</tt></td>
</tr>
<tr>
<td><tt class="literal">index</tt></td>
<td>This is a signed integral type used for indexing into <tt class="literal"
>A</tt>.  It is also used to represent strides and index bases.</td>
</tr>
<tr>
<td><tt class="literal">index_gen</tt></td>
<td>This type is used to create a tuple of <tt class="literal"
>index_range</tt>s passed to <tt class="literal">operator[]</tt> to create an
<tt class="literal">array_view&lt;Dims&gt;::type</tt> object.</td>
</tr>
<tr>
<td><tt class="literal">index_range</tt></td>
<td>This type specifies a range of indices over some dimension of a
<strong>MultiArray</strong>.  This range will be visible through an 
<tt class="literal">array_view&lt;Dims&gt;::type</tt> object.</td>
</tr>
<tr>
<td><tt class="literal">template subarray&lt;Dims&gt;::type</tt></td>
<td>This is subarray type with <tt class="literal">Dims</tt> dimensions.  It
is the reference type of the <tt class="literal">(NumDims - Dims)</tt>
dimension of <tt class="literal">A</tt> and also models
<strong>MultiArray</strong>.</td>
</tr>
<tr>
<td><tt class="literal">template const_subarray&lt;Dims&gt;::type</tt></td>
<td>This is the <tt class="literal">const</tt> subarray type.</td>
</tr>
<tr>
<td><tt class="literal">template array_view&lt;Dims&gt;::type</tt></td>
<td>This is the view type with <tt class="literal">Dims</tt> dimensions.  It
is returned by calling <tt class="literal">operator[](<tt class="literal"
>indices</tt>)</tt>.  It models <strong>MultiArray</strong>.</td>
</tr>
<tr>
<td><tt class="literal">template const_array_view&lt;Dims&gt;::type</tt></td>
<td>This is the <tt class="literal">const</tt> view type with
<tt class="literal">Dims</tt> dimensions.</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break" />
</div>
<div class="sect2" title="Valid expressions">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="idp18501744"></a>Valid expressions</h3>
</div>
</div>
</div>
<div class="table"><a name="idp18502256"></a>
<p class="title"><b>Table 3. Valid Expressions</b></p>
<div class="table-contents">
<table summary="Valid Expressions" border="1">
<colgroup><col /><col /><col /></colgroup>
<thead>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Semantics</th>
</tr>
</thead>
<tbody>
<tr>
<td><tt class="literal">A::dimensionality</tt></td>
<td><tt class="literal">size_type</tt></td>
<td>This compile-time constant represents the number of dimensions of the
array (note that <tt class="literal">A::dimensionality == NumDims</tt>).</td>
</tr>
<tr>
<td><tt class="literal">a.shape()</tt></td>
<td><tt class="literal">size_type const*</tt></td>
<td>This returns a list of <tt class="literal">NumDims</tt> elements
specifying the extent of each array dimension.</td>
</tr>
<tr>
<td><tt class="literal">a.strides()</tt></td>
<td><tt class="literal">index const*</tt></td>
<td>This returns a list of <tt class="literal">NumDims</tt> elements
specifying the stride associated with each array dimension.  When accessing
values, <tt class="literal">strides()</tt> is used to calculate an element's
location in memory.</td>
</tr>
<tr>
<td><tt class="literal">a.index_bases()</tt></td>
<td><tt class="literal">index const*</tt></td>
<td>This returns a list of <tt class="literal">NumDims</tt> elements
specifying the numeric index of the first element for each array
dimension.</td>
</tr>
<tr>
<td><tt class="literal">a.origin()</tt></td>
<td><tt class="literal">element*</tt> if <code class="literal">a</code> is
mutable, <tt class="literal">element const*</tt> otherwise.</td>
<td>This returns the address of the element accessed by the expression
<tt class="literal">a[0][0]...[0].</tt>.  If the index bases are positive,
this element won't exist, but the address can still be used to locate a valid
element given its indices.</td>
</tr>
<tr>
<td><tt class="literal">a.num_dimensions()</tt></td>
<td><tt class="literal">size_type</tt></td>
<td>This returns the number of dimensions of the array (note that
<tt class="literal">a.num_dimensions() == NumDims</tt>).</td>
</tr>
<tr>
<td><tt class="literal">a.num_elements()</tt></td>
<td><tt class="literal">size_type</tt></td>
<td>This returns the number of elements contained in the array.  It is
equivalent to the following code:
<pre class="programlisting">
    std::accumulate(
        a.shape()
      , a.shape + a.num_dimensions()
      , size_type(1)
      , std::multiplies&lt;size_type&gt;()
    );
</pre>
</td>
</tr>
<tr>
<td><tt class="literal">a.size()</tt></td>
<td><tt class="literal">size_type</tt></td>
<td>This returns the number of values contained in
<tt class="literal">a</tt>.  It is equivalent to
<tt class="literal">a.shape()[0];</tt></td>
</tr>
<tr>
<td><tt class="literal">a(index_list)</tt></td>
<td><tt class="literal">element&amp;</tt> if <tt class="literal">a</tt> is
mutable, <tt class="literal">element const&amp;</tt> otherwise.</td>
<td>This expression accesses a specific element of
<tt class="literal">a</tt>.  <tt class="literal">index_list</tt> is the unique
set of indices that address the element returned.  It is equivalent to the
following code (disregarding intermediate temporaries):
<pre class="programlisting">
    // multiply indices by strides
    std::transform(
        index_list.begin()
      , index_list.end()
      , a.strides()
      , tmp.begin()
      , std::multiplies&lt;index&gt;()
    ),

    // add the sum of the products to the origin
    *std::accumulate(tmp.begin(), tmp.end(), a.origin());
</pre>
</td>
</tr>
<tr>
<td><tt class="literal">a.begin()</tt></td>
<td><tt class="literal">iterator</tt> if <tt class="literal">a</tt> is
mutable, <tt class="literal">const_iterator</tt> otherwise.</td>
<td>This returns an iterator pointing to the beginning of
<tt class="literal">a</tt>.</td>
</tr>
<tr>
<td><tt class="literal">a.end()</tt></td>
<td><tt class="literal">iterator</tt> if <tt class="literal">a</tt> is
mutable, <tt class="literal">const_iterator</tt> otherwise.</td>
<td>This returns an iterator pointing to the end of
<tt class="literal">a</tt>.</td>
</tr>
<tr>
<td><tt class="literal">a.rbegin()</tt></td>
<td><tt class="literal">reverse_iterator</tt> if <tt class="literal">a</tt> is
mutable, <tt class="literal">const_reverse_iterator</tt> otherwise.</td>
<td>This returns a reverse iterator pointing to the beginning of
<tt class="literal">a</tt> reversed.</td>
</tr>
<tr>
<td><tt class="literal">a.rend()</tt></td>
<td><tt class="literal">reverse_iterator</tt> if <tt class="literal">a</tt> is
mutable, <tt class="literal">const_reverse_iterator</tt> otherwise.</td>
<td>This returns a reverse iterator pointing to the end of
<tt class="literal">a</tt> reversed.</td>
</tr>
<tr>
<td><tt class="literal">a[idx]</tt></td>
<td><tt class="literal">reference</tt> if <tt class="literal">a</tt> is
mutable, <tt class="literal">const_reference</tt> otherwise.</td>
<td>This returns a reference type that is bound to the index
<tt class="literal">idx</tt> value of <tt class="literal">a</tt>.  Note that
if <tt class="literal">i</tt> is the index base for this dimension, the above
expression returns the <tt class="literal">(idx - i)</tt>th element (counting
from zero).  The expression is equivalent to
<tt class="literal">*(a.begin() + idx - a.index_bases()[0]);</tt>.</td>
</tr>
<tr>
<td><tt class="literal">a[indices]</tt></td>
<td><tt class="literal">array_view&lt;Dims&gt;::type</tt> if
<tt class="literal">a</tt> is mutable,
<tt class="literal">const_array_view&lt;Dims&gt;::type</tt> otherwise.</td>
<td>This expression generates a view of the array determined by the
<tt class="literal">index_range</tt> and <tt class="literal">index</tt> values
used to construct <tt class="literal">indices</tt>.</td>
</tr>
<tr>
<td><tt class="literal">a == b</tt></td>
<td><tt class="literal">bool</tt></td>
<td>This performs a lexicographical comparison of the values of
<tt class="literal">a</tt> and <tt class="literal">b</tt>.  The element type
must model <a class="ulink" href=
"http://www.rrsd.com/software_development/stl/stl/EqualityComparable.html"
target="_top"><strong>EqualityComparable</strong></a> for this expression to
be valid.</td>
</tr>
<tr>
<td><tt class="literal">a &lt; b</tt></td>
<td><tt class="literal">bool</tt></td>
<td>This performs a lexicographical comparison of the values of
<tt class="literal">a</tt> and <tt class="literal">b</tt>.  The element type
must model <a class="ulink" href=
"http://www.rrsd.com/software_development/stl/stl/LessThanComparable.html"
target="_top"><strong>LessThanComparable</strong></a> for this expression to
be valid.</td>
</tr>
<tr>
<td><tt class="literal">a &lt;= b</tt></td>
<td><tt class="literal">bool</tt></td>
<td>This performs a lexicographical comparison of the values of
<tt class="literal">a</tt> and <tt class="literal">b</tt>.  The element type
must model <a class="ulink" href=
"http://www.rrsd.com/software_development/stl/stl/EqualityComparable.html"
target="_top"><strong>EqualityComparable</strong></a> and
<a class="ulink" href=
"http://www.rrsd.com/software_development/stl/stl/LessThanComparable.html"
target="_top"><strong>LessThanComparable</strong></a> for this expression to
be valid.</td>
</tr>
<tr>
<td><tt class="literal">a &gt; b</tt></td>
<td><tt class="literal">bool</tt></td>
<td>This performs a lexicographical comparison of the values of
<tt class="literal">a</tt> and <tt class="literal">b</tt>.  The element type
must model <a class="ulink" href=
"http://www.rrsd.com/software_development/stl/stl/EqualityComparable.html"
target="_top"><strong>EqualityComparable</strong></a> and
<a class="ulink" href=
"http://www.rrsd.com/software_development/stl/stl/LessThanComparable.html"
target="_top"><strong>LessThanComparable</strong></a> for this expression to
be valid.</td>
</tr>
<tr>
<td><tt class="literal">a &gt;= b</tt></td>
<td><tt class="literal">bool</tt></td>
<td>This performs a lexicographical comparison of the values of
<tt class="literal">a</tt> and <tt class="literal">b</tt>.  The element type
must model <a class="ulink" href=
"http://www.rrsd.com/software_development/stl/stl/LessThanComparable.html"
target="_top"><strong>LessThanComparable</strong></a> for this expression to
be valid.</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break" />
</div>
<div class="sect2" title="Complexity guarantees">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="idp18588736"></a>Complexity guarantees</h3>
</div>
</div>
</div>
<ul>
<li><tt class="literal">begin()</tt> and <tt class="literal">end()</tt>
execute in amortized constant time.</li>
<li><tt class="literal">size()</tt> executes in at most linear time in the
<strong>MultiArray</strong>'s size.</li>
</ul>
</div>
<div class="sect2" title="Invariants">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="idp18591264"></a>Invariants</h3>
</div>
</div>
</div>
<div class="table"><a name="idp18591904"></a>
<p class="title"><b>Table 4. Invariants</b></p>
<div class="table-contents">
<table summary="Invariants" border="1">
<colgroup><col /><col /></colgroup>
<tbody>
<tr>
<td>Valid range</td>
<td><tt class="literal">[a.begin(),a.end())</tt> is a valid range.</td>
</tr>
<tr>
<td>Range size</td>
<td><tt class="literal">a.size() == std::distance(a.begin(),
a.end());</tt>.</td>
</tr>
<tr>
<td>Completeness</td>
<td>Iteration through the range <tt class="literal">[a.begin(), a.end())</tt>
will traverse across every <tt class="literal">value_type</tt> of
<tt class="literal">a</tt>.</td>
</tr>
<tr>
<td>Accessor Equivalence</td>
<td>Calling <tt class="literal">a[a1][a2]...[aN]</tt> where <tt
class="literal">N == NumDims</tt> yields the same result as calling <tt
class="literal">a(index_list)</tt>, where <tt class="literal">index_list</tt>
is a <a class="ulink" href="../../utility/Collection.html" target="_top"
><strong>Collection</strong></a> containing the values
<tt class="literal">a1...aN</tt>.</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break" />
</div>
<div class="sect2" title="Associated Types for Views">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="view_types"></a>Associated Types for Views</h3>
</div>
</div>
</div>
<p>The following <strong>MultiArray</strong> associated types define the
interface for creating views of existing <strong>MultiArrays</strong>.  Their
interfaces and roles in the concept are described below.</p>
<div class="sect3" title="index_range">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="index_range"></a><tt class="literal"
>index_range</tt></h4>
</div>
</div>
</div>
<p><tt class="literal">index_range</tt> objects represent half-open strided
intervals.  They are aggregated (using an <tt class="literal">index_gen</tt>
object) and passed to a <strong>MultiArray</strong>'s <tt class="literal"
>operator[]</tt> to create an array view. When creating a view, each
<tt class="literal">index_range</tt> denotes a range of valid indices along
one dimension of a <strong>MultiArray</strong>.  Elements that are accessed
through the set of ranges specified will be included in the constructed
view.  In some cases, an <tt class="literal">index_range</tt> is created
without specifying start or finish values.  In those cases, the object is
interpreted to start at the beginning of a <strong>MultiArray</strong>
dimension and end at its end.</p>
<p><tt class="literal">index_range</tt> objects can be constructed and
modified several ways in order to allow convenient and clear expression of a
range of indices.  To specify ranges, <tt class="literal">index_range</tt>
supports a set of constructors, mutating member functions, and a novel 
specification involving inequality operators.  Using inequality
operators, a half open range [5, 10) can be specified as follows:</p>
<pre class="programlisting">5 &lt;= index_range() &lt; 10;</pre>
<p>or</p>
<pre class="programlisting">4 &lt; index_range() &lt;= 9;</pre>
<p> and so on.</p>
<p>The following describes the <tt class="literal">index_range</tt>
interface.</p>
<div class="table"><a name="idp18614960"></a>
<p class="title"><strong>Table 5. Notation</strong></p>
<div class="table-contents">
<table summary="Notation" border="1">
<colgroup><col /><col /></colgroup>
<tbody>
<tr>
<td><tt class="literal">i</tt></td>
<td>An object of type <tt class="literal">index_range</tt>.</td>
</tr>
<tr>
<td><tt class="literal">idx, idx1, idx2, idx3</tt></td>
<td>Objects of type <tt class="literal">index</tt>.</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break" />
<div class="table"><a name="idp18620944"></a>
<p class="title"><strong>Table 6. Associated Types</strong></p>
<div class="table-contents">
<table summary="Associated Types" border="1">
<colgroup><col /><col /></colgroup>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><tt class="literal">index</tt></td>
<td>This is a signed integral type.  It is used to specify the start, finish,
and stride values.</td>
</tr>
<tr>
<td><tt class="literal">size_type</tt></td>
<td>This is an unsigned integral type.  It is used to report the size of the
range an <tt class="literal">index_range</tt> represents.</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break" />
<div class="table"><a name="idp18627920"></a>
<p class="title"><strong>Table 7. Valid Expressions</strong></p>
<div class="table-contents">
<table summary="Valid Expressions" border="1">
<colgroup><col /><col /><col /></colgroup>
<thead>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Semantics</th>
</tr>
</thead>
<tbody>
<tr>
<td><tt class="literal">index_range(idx1, idx2, idx3)</tt></td>
<td><tt class="literal">index_range</tt></td>
<td>This constructs an <tt class="literal">index_range</tt> representing the
interval <tt class="literal">[idx1,idx2)</tt> with stride
<tt class="literal">idx3</tt>.</td>
</tr>
<tr>
<td><tt class="literal">index_range(idx1, idx2)</tt></td>
<td><tt class="literal">index_range</tt></td>
<td>This constructs an <tt class="literal">index_range</tt> representing the
interval <tt class="literal">[idx1, idx2)</tt> with unit stride.  It is
equivalent to <tt class="literal">index_range(idx1, idx2, 1)</tt>.</td>
</tr>
<tr>
<td><tt class="literal">index_range()</tt></td>
<td><tt class="literal">index_range</tt></td>
<td>This construct an <tt class="literal">index_range</tt> with unspecified
start and finish values.</td></tr>
<tr>
<td><tt class="literal">i.start(idx1)</tt></td>
<td><tt class="literal">index&amp;</tt></td>
<td>This sets the start index of <tt class="literal">i</tt> to
<tt class="literal">idx</tt>.</td>
</tr>
<tr>
<td><tt class="literal">i.finish(idx)</tt></td>
<td><tt class="literal">index&amp;</tt></td>
<td>This sets the finish index of <tt class="literal">i</tt> to 
<tt class="literal">idx</tt>.</td>
</tr>
<tr>
<td><tt class="literal">i.stride(idx)</tt></td>
<td><tt class="literal">index&amp;</tt></td>
<td>This sets the stride length of <tt class="literal">i</tt> to
<tt class="literal">idx</tt>.</td>
</tr>
<tr>
<td><tt class="literal">i.start()</tt></td>
<td><tt class="literal">index</tt></td>
<td>This returns the start index of <tt class="literal">i</tt>.</td>
</tr>
<tr>
<td><tt class="literal">i.finish()</tt></td>
<td><tt class="literal">index</tt></td>
<td>This returns the finish index of <code class="literal">i</code>.</td>
</tr>
<tr>
<td><tt class="literal">i.stride()</tt></td>
<td><tt class="literal">index</tt></td>
<td>This returns the stride length of <tt class="literal">i</tt>.</td>
</tr>
<tr>
<td><tt class="literal">i.get_start(idx)</tt></td>
<td><tt class="literal">index</tt></td>
<td>If <tt class="literal">i</tt> specifies a start value, this is equivalent
to <tt class="literal">i.start()</tt>.  Otherwise it returns
<tt class="literal">idx</tt>.</td>
</tr>
<tr>
<td><tt class="literal">i.get_finish(idx)</tt></td>
<td><tt class="literal">index</tt></td>
<td>If <tt class="literal">i</tt> specifies a finish value, this is equivalent
to <tt class="literal">i.finish()</tt>.  Otherwise it returns
<tt class="literal">idx</tt>.</td>
</tr>
<tr>
<td><tt class="literal">i.size(idx)</tt></td>
<td><tt class="literal">size_type</tt></td>
<td>If <tt class="literal">i</tt> specifies a both finish and start values,
this is equivalent to <tt class="literal">(i.finish() - i.start()) /
i.stride()</tt>.  Otherwise it returns <tt class="literal">idx</tt>.</td>
</tr>
<tr>
<td><tt class="literal">i &lt; idx</tt></td>
<td><tt class="literal">index</tt></td>
<td>This is another syntax for specifying the finish value. This notation does
not include <tt class="literal">idx</tt> in the range of valid indices.  It is
equivalent to <tt class="literal">index_range(r.start(), idx,
r.stride())</tt></td>
</tr>
<tr>
<td><tt class="literal">i &lt;= idx</tt></td>
<td><tt class="literal">index</tt></td>
<td>This is another syntax for specifying the finish value.  This notation
includes <tt class="literal">idx</tt> in the range of valid indices. It is
equivalent to <tt class="literal">index_range(r.start(), idx + 1,
r.stride())</tt></td>
</tr>
<tr>
<td><tt class="literal">idx &lt; i</tt></td>
<td><tt class="literal">index</tt></td>
<td>This is another syntax for specifying the start value.  This notation does
not include <tt class="literal">idx</tt> in the range of valid indices.  It is
equivalent to <tt class="literal">index_range(idx + 1, i.finish(),
i.stride())</tt>.</td>
</tr>
<tr>
<td><tt class="literal">idx &lt;= i</tt></td>
<td><tt class="literal">index</tt></td>
<td>This is another syntax for specifying the start value.  This notation
includes <tt class="literal">idx1</tt> in the range of valid indices.  It is
equivalent to <tt class="literal">index_range(idx, i.finish(),
i.stride())</tt>.</td>
</tr>
<tr>
<td><tt class="literal">i + idx</tt></td>
<td><tt class="literal">index</tt></td>
<td>This expression shifts the start and finish values of <tt class="literal"
>i</tt> up by <tt class="literal">idx</tt>.  It is equivalent to 
<tt class="literal">index_range(r.start() + idx1, r.finish() + idx,
r.stride())</tt></td>
</tr>
<tr>
<td><tt class="literal">i - idx</tt></td>
<td><tt class="literal">index</tt></td>
<td>This expression shifts the start and finish values of <tt class="literal"
>i</tt> up by <tt class="literal">idx</tt>.  It is equivalent to 
<tt class="literal">index_range(r.start() - idx1, r.finish() - idx,
r.stride())</tt>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break" />
</div>
<div class="sect3" title="index_gen">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="index_gen"></a><tt class="literal"
>index_gen</tt></h4>
</div>
</div>
</div>
<p><tt class="literal">index_gen</tt> aggregates <tt class="literal"
>index_range</tt> objects in order to specify view parameters.  Chained calls
to <tt class="literal">operator[]</tt> store range and dimension information
used to instantiate a new view into a <strong>MultiArray</strong>.</p>
<div class="table"><a name="idp18699808"></a>
<p class="title"><strong>Table 8. Notation</strong></p>
<div class="table-contents">
<table summary="Notation" border="1">
<colgroup><col /><col /></colgroup>
<tbody>
<tr>
<td><tt class="literal">Dims,Ranges</tt></td>
<td>Unsigned integral values.</td></tr>
<tr>
<td><tt class="literal">x</tt></td>
<td>An object of type 
<tt class="literal">template gen_type&lt;Dims,Ranges&gt;::type</tt>.</td>
</tr>
<tr>
<td><tt class="literal">i</tt></td>
<td>An object of type <tt class="literal">index_range</tt>.</td>
</tr>
<tr>
<td><tt class="literal">idx</tt></td>
<td>Objects of type <tt class="literal">index</tt>.</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break" />
<div class="table"><a name="idp18709408"></a>
<p class="title"><strong>Table 9. Associated Types</strong></p>
<div class="table-contents">
<table summary="Associated Types" border="1">
<colgroup><col /><col /></colgroup>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><tt class="literal">index</tt></td>
<td>This is a signed integral type.  It is used to specify degenerate
dimensions.</td>
</tr>
<tr>
<td><tt class="literal">size_type</tt></td>
<td>This is an unsigned integral type.  It is used to report the size of the
range an <tt class="literal">index_range</tt> represents.</td>
</tr>
<tr>
<td><tt class="literal">template
gen_type::&lt;Dims,Ranges&gt;::type</tt></td>
<td>This type generator names the result of <tt class="literal">Dims</tt>
chained calls to <tt class="literal">index_gen::operator[]</tt>.  The
<tt class="literal">Ranges</tt> parameter is determined by the number of
degenerate ranges specified (i.e. calls to <tt class="literal"
>operator[](index)</tt>).  Note that <tt class="classname">index_gen</tt> and
<tt class="classname">gen_type&lt;0,0&gt;::type</tt> are the same type.</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break" />
<div class="table"><a name="idp18721296"></a>
<p class="title"><b>Table 10. Valid Expressions</b></p>
<div class="table-contents">
<table summary="Valid Expressions" border="1">
<colgroup><col /><col /><col /></colgroup>
<thead>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Semantics</th>
</tr>
</thead>
<tbody>
<tr>
<td><tt class="literal">index_gen()</tt></td>
<td><tt class="literal">gen_type&lt;0,0&gt;::type</tt></td>
<td>This constructs an <tt class="literal">index_gen</tt> object.  This object
can then be used to generate tuples of <tt class="literal">index_range</tt>
values.</td>
</tr>
<tr>
<td><tt class="literal">x[i]</tt></td>
<td><tt class="literal">gen_type&lt;Dims+1,Ranges+1&gt;::type</tt></td>
<td>Returns a new object containing all previous
<tt class="classname">index_range</tt> objects in addition to
<tt class="literal">i.</tt>  Chained calls to
<tt class="function">operator[]</tt> are the means by which
<tt class="classname">index_range</tt> objects are aggregated.</td>
</tr>
<tr>
<td><tt class="literal">x[idx]</tt></td>
<td><tt class="literal">gen_type&lt;Dims,Ranges+1&gt;::type</tt></td>
<td>Returns a new object containing all previous <tt class="classname"
>index_range</tt> objects in addition to a degenerate range,
<code class="literal">index_range(idx, idx).</code>  Note that this is NOT
equivalent to <tt class="literal">x[index_range(idx, idx)].</tt>, which will
return an object of type
<tt class="literal">gen_type&lt;Dims+1,Ranges+1&gt;::type</tt>.</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break" />
</div>
</div>
<div class="sect2" title="Models">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="idp18737792"></a>Models</h3>
</div>
</div>
</div>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem"><tt class="literal">multi_array</tt></li>
<li class="listitem"><tt class="literal">multi_array_ref</tt></li>
<li class="listitem"><tt class="literal">const_multi_array_ref</tt></li>
<li class="listitem"><tt class="literal">template
array_view&lt;Dims&gt;::type</tt></li>
<li class="listitem"><tt class="literal">template
const_array_view&lt;Dims&gt;::type</tt></li>
<li class="listitem"><tt class="literal">template
subarray&lt;Dims&gt;::type</tt></li>
<li class="listitem"><tt class="literal">template
const_subarray&lt;Dims&gt;::type</tt></li>
</ul>
</div>
</div>
</div>
<div class="sect1" title="Array Components">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="array_types"></a>Array
Components</h2>
</div>
</div>
</div>
<p>Boost.MultiArray defines an array class,
<tt class="literal">multi_array</tt>, and two adapter classes,
<tt class="literal">multi_array_ref</tt> and
<tt class="literal">const_multi_array_ref</tt>.  The three classes model
<strong>MultiArray</strong> and so they share a lot of
functionality.  <tt class="literal">multi_array_ref</tt> differs from
<tt class="literal">multi_array</tt> in that the <tt class="literal"
>multi_array</tt> manages its own memory, while <tt class="literal"
>multi_array_ref</tt> is passed a block of memory that it expects to be
externally managed.  <tt class="literal">const_multi_array_ref</tt> differs
from <tt class="literal">multi_array_ref</tt> in that the underlying elements
it adapts cannot be modified through its interface, though some array
properties, including the array shape and index bases, can be
altered.  Functionality the classes have in common is described below.</p>
<p title="Note: Preconditions, Effects, and Implementation"><strong>Note:
Preconditions, Effects, and Implementation.</strong>  Throughout the following
sections, small pieces of C++ code are used to specify constraints such as
preconditions, effects, and postconditions.  These do not necessarily describe
the underlying implementation of array components; rather, they describe the 
expected input to and behavior of the specified operations.  Failure to meet
preconditions results in undefined behavior.  Not all effects (i.e. copy
constructors, etc.) must be mimicked exactly.  The code snippets for effects
intend to capture the essence of the described operation.</p>
<p title="Queries"><strong>Queries.</strong></p>
<div class="variablelist">
<dl>
<dt><span class="term"><pre class="programlisting">
    element* data();
    element const* data() const;
</pre></span></dt>
<dd><p>This returns a pointer to the beginning of the contiguous block that
contains the array's data.  If all dimensions of the array are 0-indexed and
stored in ascending order, this is equivalent to <tt class="literal"
>origin()</tt>.  Note that <tt class="literal">const_multi_array_ref</tt> only
provides the <tt class="literal">const</tt> version of this function.</p></dd>
<dt><span class="term"><pre class="programlisting">
    element* origin();
    element const* origin() const;
</pre></span></dt>
<dd><p>This returns the origin element of the <tt class="literal"
>multi_array</tt>.  Note that <tt class="literal">const_multi_array_ref</tt>
only provides the <tt class="literal">const</tt> version of this
function.  (Required by MultiArray)</p></dd>
<dt><span class="term"><pre class="programlisting">
    index const* index_bases();
</pre></span></dt>
<dd><p>This returns the index bases for the
<tt class="literal">multi_array</tt>.  (Required by MultiArray)</p></dd>
<dt><span class="term"><pre class="programlisting">
    index const* strides();
</pre></span></dt>
<dd><p>This returns the strides for the
<tt class="literal">multi_array</tt>.  (Required by MultiArray)</p></dd>
<dt><span class="term"><pre class="programlisting">
    size_type const* shape();
</pre></span></dt>
<dd><p>This returns the shape of the
<tt class="literal">multi_array</tt>.  (Required by MultiArray)</p></dd>
</dl>
</div>
<p title="Comparators"><strong>Comparators.</strong></p>
<div class="variablelist">
<dl>
<dt><span class="term"><pre class="programlisting">
    bool operator==(<em>array-type</em> const&amp; rhs);
    bool operator!=(<em>array-type</em> const&amp; rhs);
    bool operator&lt;(<em>array-type</em> const&amp; rhs);
    bool operator&gt;(<em>array-type</em> const&amp; rhs);
    bool operator&gt;=(<em>array-type</em> const&amp; rhs);
    bool operator&lt;=(<em>array-type</em> const&amp; rhs);
</pre></span></dt>
<dd><p>Each comparator executes a lexicographical compare over the value types
of the two arrays.  (Required by MultiArray)</p>
<p title="Preconditions"><strong>Preconditions.</strong>  <tt class="literal"
>element</tt> must support the comparator corresponding to that called on
<tt class="literal">multi_array</tt>.</p>
<p title="Complexity"><b>Complexity.</b>  O(<tt class="literal"
>num_elements()</tt>).</p></dd>
</dl>
</div>
<p title="Modifiers"><strong>Modifiers.</strong></p>
<div class="variablelist">
<dl>
<dt><span class="term"><pre class="programlisting">
    template &lt;typename SizeList&gt;
    void reshape(SizeList const&amp; sizes);
</pre></span></dt>
<dd><p>This changes the shape of the
<tt class="literal">multi_array</tt>.  The number of elements and the index
bases remain the same, but the number of values at each level of the nested
container hierarchy may change.</p>
<p title="SizeList Requirements"><strong><tt class="literal">SizeList</tt>
Requirements.</strong>  <tt class="literal">SizeList</tt> must model
<a class="ulink" href="../../utility/Collection.html" target="_top"
><strong>Collection</strong></a>.</p>
<p title="Preconditions"><strong>Preconditions.</strong></p>
<pre class="programlisting">
    std::accumulate(
        sizes.begin()
      , sizes.end()
      , size_type(1)
      , std::times&lt;size_type&gt;()
    ) == this-&gt;num_elements();
    sizes.size() == NumDims;
</pre>
<p title="Postconditions"><strong>Postconditions.</strong></p>
<pre class="programlisting">
    std::equal(sizes.begin(), sizes.end(), this-&gt;shape) == true;
</pre></dd>
<dt><span class="term"><pre class="programlisting">
    template &lt;typename BaseList&gt;
    void reindex(BaseList const&amp; values);
</pre></span></dt>
<dd><p>This changes the index bases of the
<tt class="literal">multi_array</tt> to correspond to the the values in
<tt class="literal">values</tt>.</p>
<p title="BaseList Requirements"><b><tt class="literal">BaseList</tt>
Requirements.</b>  <tt class="literal">BaseList</tt> must model
<a class="ulink" href="../../utility/Collection.html" target="_top"
><strong>Collection</strong></a>.</p>
<p title="Preconditions"><strong>Preconditions.</strong>  <tt class="literal"
>values.size() == NumDims;</tt></p>
<p title="Postconditions"><strong>Postconditions.</strong></p>
<pre class="programlisting">
    std::equal(values.begin(), values.end(), this-&gt;index_bases());
</pre></dd>
<dt><span class="term"><pre class="programlisting">
    void reindex(index value);
</pre></span></dt>
<dd><p>This changes the index bases of all dimensions of the
<tt class="literal">multi_array</tt> to <tt class="literal">value</tt>.</p>
<p title="Postconditions"><strong>Postconditions.</strong></p>
<pre class="programlisting">
    std::count_if(
        this-&gt;index_bases()
      , this-&gt;index_bases() + this-&gt;num_dimensions()
      , std::bind_2nd(std::equal_to&lt;index&gt;(), value)
    ) == this-&gt;num_dimensions();
</pre></dd>
</dl>
</div>
<div class="sect2" title="multi_array">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="multi_array_class"></a><tt class="literal"
>multi_array</tt></h3>
</div>
</div>
</div>
<p><tt class="literal">multi_array</tt> is a multi-dimensional container that
supports random access iteration.  Its number of dimensions is fixed at
compile time, but its shape and the number of elements it contains are
specified during its construction.  The number of elements will remain fixed
for the duration of a <tt class="literal">multi_array</tt>'s lifetime, but the
shape of the container can be changed.  A <tt class="literal">multi_array</tt>
manages its data elements using a replaceable allocator.</p>
<p title="Model Of."><strong>Model Of.</strong></p>
<ul>
<li><a class="link" href="#MultiArray" title="MultiArray Concept"
><strong>MultiArray</strong></a></li>
<li><a class="ulink" href="../../../libs/utility/CopyConstructible.html"
target="_top"><strong>CopyConstructible</strong></a></li>
<li><a class="ulink" href=
"http://www.rrsd.com/software_development/stl/stl/EqualityComparable.html"
target="_top"><strong>EqualityComparable</strong></a> if the element type is
<a class="ulink" href=
"http://www.rrsd.com/software_development/stl/stl/EqualityComparable.html"
target="_top"><strong>EqualityComparable</strong></a></li>
<li><a class="ulink" href=
"http://www.rrsd.com/software_development/stl/stl/LessThanComparable.html"
target="_top"><strong>LessThanComparable</strong></a> if the element type is
<a class="ulink" href=
"http://www.rrsd.com/software_development/stl/stl/LessThanComparable.html"
target="_top"><strong>LessThanComparable</strong></a></li>
</ul>
<p title="Synopsis"><strong>Synopsis.</strong></p>
<pre class="programlisting">
namespace boost {

    template &lt;
        typename ValueType
      , std::size_t NumDims
      , typename Allocator = std::allocator&lt;ValueType&gt;
    &gt;
    class multi_array
    {
     public:
        // types:
        typedef ValueType                             element;
        typedef *unspecified*                         value_type;
        typedef *unspecified*                         reference;
        typedef *unspecified*                         const_reference;
        typedef *unspecified*                         difference_type;
        typedef *unspecified*                         iterator;
        typedef *unspecified*                         const_iterator;
        typedef *unspecified*                         reverse_iterator;
        typedef *unspecified*                         const_reverse_iterator;
        typedef multi_array_types::size_type          size_type;
        typedef multi_array_types::index              index;
        typedef multi_array_types::index_gen          index_gen;
        typedef multi_array_types::index_range        index_range;
        typedef multi_array_types::extent_gen         extent_gen;
        typedef multi_array_types::extent_range       extent_range;
        typedef *unspecified*                         storage_order_type;

        // template typedefs
        template &lt;std::size_t Dims&gt; struct            subarray;
        template &lt;std::size_t Dims&gt; struct            const_subarray;
        template &lt;std::size_t Dims&gt; struct            array_view;
        template &lt;std::size_t Dims&gt; struct            const_array_view;

        static std::size_t const dimensionality = NumDims;

        // constructors and destructors

        multi_array();

        template &lt;typename ExtentList&gt;
        explicit multi_array(
            ExtentList const&amp; sizes
          , storage_order_type const&amp; store = c_storage_order()
          , Allocator const&amp; alloc = Allocator()
        );
        explicit multi_array(
            extents_tuple const&amp; ranges
          , storage_order_type const&amp; store = c_storage_order()
	      , Allocator const&amp; alloc = Allocator()
        );
        multi_array(multi_array const&amp; x);
        multi_array(
            const_multi_array_ref&lt;ValueType,NumDims&gt; const&amp; x
        );
        multi_array(const_subarray&lt;NumDims&gt;::type const&amp; x);
        multi_array(const_array_view&lt;NumDims&gt;::type const&amp; x);

        multi_array(multi_array_ref&lt;ValueType,NumDims&gt; const&amp; x);
        multi_array(subarray&lt;NumDims&gt;::type const&amp; x);
        multi_array(array_view&lt;NumDims&gt;::type const&amp; x);

        ~multi_array();

        // modifiers

        multi_array&amp; operator=(multi_array const&amp; x);
        template &lt;typename Array&gt;
        multi_array&amp; operator=(Array const&amp; x);

        // iterators:
        iterator begin();
        iterator end();
        const_iterator begin() const;
        const_iterator end() const;
        reverse_iterator rbegin();
        reverse_iterator rend();
        const_reverse_iterator rbegin() const;
        const_reverse_iterator rend() const;

        // capacity:
        size_type size() const;
        size_type num_elements() const;
        size_type num_dimensions() const;

        // element access:
        template &lt;typename IndexList&gt;
        element&amp; operator()(IndexList const&amp; indices);
        template &lt;typename IndexList&gt;
        element const&amp; operator()(IndexList const&amp; indices) const;
        reference operator[](index i);
        const_reference operator[](index i) const;
        array_view&lt;Dims&gt;::type operator[](indices_tuple const&amp; r);
        const_array_view&lt;Dims&gt;::type
            operator[](indices_tuple const&amp; r) const;

        // queries
        element* data();
        element const* data() const;
        element* origin();
        element const* origin() const;
        size_type const* shape() const;
        index const* strides() const;
        index const* index_bases() const;
        storage_order_type const&amp; storage_order() const;

        // comparators
        bool operator==(multi_array const&amp; rhs);
        bool operator!=(multi_array const&amp; rhs);
        bool operator&lt;(multi_array const&amp; rhs);
        bool operator&gt;(multi_array const&amp; rhs);
        bool operator&gt;=(multi_array const&amp; rhs);
        bool operator&lt;=(multi_array const&amp; rhs);

        // modifiers:
        template &lt;typename InputIterator&gt;
        void assign(InputIterator begin, InputIterator end);
        template &lt;typename SizeList&gt;
        void reshape(SizeList const&amp; sizes)
        template &lt;typename BaseList&gt;
        void reindex(BaseList const&amp; values);
        void reindex(index value);
        template &lt;typename ExtentList&gt;
        multi_array&amp; resize(ExtentList const&amp; extents);
        multi_array&amp; resize(extents_tuple&amp; extents);
    };
} // namespace boost
</pre>
<p title="Constructors"><strong>Constructors.</strong></p>
<div class="variablelist">
<dl>
<dt><span class="term"><pre class="programlisting">
    template &lt;typename ExtentList&gt;
    explicit multi_array(
        ExtentList const&amp; sizes
      , storage_order_type const&amp; store = c_storage_order()
      , Allocator const&amp; alloc = Allocator()
    );
</pre></span></dt>
<dd><p>This constructs a <tt class="literal">multi_array</tt> using the
specified parameters.  <tt class="literal">sizes</tt> specifies the shape of
the constructed <tt class="literal">multi_array</tt>.  <tt class="literal"
>store</tt> specifies the storage order or layout in memory of the array
dimensions.  <tt class="literal">alloc</tt> is used to allocate the contained
elements.</p>
<p title="ExtentList Requirements"><strong><tt class="literal">ExtentList</tt>
Requirements.</strong>  <tt class="literal">ExtentList</tt> must model
<a class="ulink" href="../../utility/Collection.html" target="_top"
><strong>Collection</strong></a>.</p>
<p title="Preconditions"><strong>Preconditions.</strong>  <tt class="literal"
>sizes.size() == NumDims;</tt></p></dd>
<dt><span class="term"><pre class="programlisting">
    explicit multi_array(
        extent_gen::gen_type&lt;NumDims&gt;::type ranges
      , storage_order_type const&amp; store = c_storage_order()
      , Allocator const&amp; alloc = Allocator()
    );
</pre></span></dt>
<dd><p>This constructs a <tt class="literal">multi_array</tt> using the
specified parameters.  <tt class="literal">ranges</tt> specifies the shape and
index bases of the constructed multi_array.  It is the result of 
<tt class="literal">NumDims</tt> chained calls to 
<tt class="literal">extent_gen::operator[]</tt>.  <tt class="literal"
>store</tt> specifies the storage order or layout in memory of the array
dimensions.  <tt class="literal">alloc</tt> is the allocator used to allocate
the memory used to store <tt class="literal">multi_array</tt>
elements.</p></dd>
<dt><span class="term"><pre class="programlisting">
    multi_array(multi_array const&amp; x);
    multi_array(const_multi_array_ref&lt;ValueType,NumDims&gt; const&amp; x);
    multi_array(const_subarray&lt;NumDims&gt;::type const&amp; x);
    multi_array(const_array_view&lt;NumDims&gt;::type const&amp; x);
    multi_array(multi_array_ref&lt;ValueType,NumDims&gt; const&amp; x);
    multi_array(subarray&lt;NumDims&gt;::type const&amp; x);
    multi_array(array_view&lt;NumDims&gt;::type const&amp; x);
</pre></span></dt>
<dd><p>These constructors all constructs a <tt class="literal"
>multi_array</tt> and perform a deep copy of <tt class="literal">x</tt>.</p>
<p title="Complexity"><strong>Complexity.</strong>  This performs
O(<tt class="literal">x.num_elements()</tt>) calls to
<tt class="literal">element</tt>'s copy constructor.</p></dd>
<dt><span class="term"><pre class="programlisting">
    multi_array();
</pre></span></dt>
<dd><p>This constructs a <tt class="literal">multi_array</tt> whose shape is
(0,...,0) and contains no elements.</p></dd>
</dl>
</div>
<p title="Note on Constructors"><strong>Note on Constructors.</strong>  The
<tt class="literal">multi_array</tt> construction expressions,</p>
<pre class="programlisting">
    multi_array&lt;int,3&gt; A(boost::extents[5][4][3]);
</pre>
<p title="Note on Constructors">and</p>
<pre class="programlisting">
    boost::array&lt;multi_array_base::index,3&gt; my_extents = {{5, 4, 3}};
    multi_array&lt;int,3&gt; A(my_extents);
</pre>
<p title="Note on Constructors">are equivalent.</p>
<p title="Modifiers"><strong>Modifiers.</strong></p>
<div class="variablelist">
<dl>
<dt><span class="term"><pre class="programlisting">
    multi_array&amp; operator=(multi_array const&amp; x);
    template &lt;typename Array&gt;
    multi_array&amp; operator=(Array const&amp; x);
</pre></span></dt>
<dd><p>This performs an element-wise copy of <tt class="literal">x</tt> into
the current <tt class="literal">multi_array</tt>.</p>
<p title="Array Requirements"><strong><tt class="literal">Array</tt>
Requirements.</strong>  <tt class="literal">Array</tt> must model 
<strong>MultiArray</strong>.</p>
<p title="Preconditions"><strong>Preconditions.</strong></p>
<pre class="programlisting">
    std::equal(
        this-&gt;shape()
      , this-&gt;shape() + this-&gt;num_dimensions()
      , x.shape()
    );
</pre>
<p title="Postconditions"><strong>Postconditions.</strong></p>
<pre class="programlisting">(*.this) == x;</pre>
<p title="Complexity"><strong>Complexity.</strong>  The assignment operators
perform O(<tt class="literal">x.num_elements()</tt>) calls to
<tt class="literal">element</tt>'s copy constructor.</p></dd>
<dt><span class="term"><pre class="programlisting">
    template &lt;typename InputIterator&gt;
    void assign(InputIterator begin, InputIterator end);
</pre></span></dt>
<dd><p>This copies the elements in the range <tt class="literal">[begin,
end)</tt> into the array.  It is equivalent to
<tt class="literal">std::copy(begin, end, this-&gt;data())</tt>.</p>
<p title="Preconditions"><strong>Preconditions.</strong>  <tt class="literal"
>std::distance(begin,end) == this-&gt;num_elements();</tt></p>
<p title="Complexity"><strong>Complexity.</strong>  The
<tt class="literal">assign</tt> member function performs
O(<tt class="literal">this-&gt;num_elements()</tt>) calls to
<tt class="literal">ValueType</tt>'s copy constructor.</p></dd>
<dt><span class="term"><pre class="programlisting">
    multi_array&amp;
        resize(extent_gen::gen_type&lt;NumDims&gt;::type extents);
    template &lt;typename ExtentList&gt;
    multi_array&amp; resize(ExtentList const&amp; extents);
</pre></span></dt>
<dd><p>This function resizes an array to the shape specified by
<tt class="literal">extents</tt>, which is either a generated list of extents
or a model of the <a class="ulink" href="../../utility/Collection.html"
target="_top"><strong>Collection</strong></a> concept.  The contents of the
array are preserved whenever possible; if the new array size is smaller, then
some data will be lost.  Any new elements created by resizing the array are
initialized with the <tt class="literal">element</tt> default
constructor.</p></dd>
</dl>
</div>
<p title="Queries"><strong>Queries.</strong></p>
<div class="variablelist">
<dl>
<dt><span class="term"><pre class="programlisting">
    storage_order_type&amp; storage_order() const;
</pre></span></dt>
<dd><p>This query returns the storage order object associated with the 
<tt class="literal">multi_array</tt> in question.  It can be used to construct
a new array with the same storage order.</p></dd>
</dl>
</div>
</div>
<div class="sect2" title="multi_array_ref">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="multi_array_ref"></a><tt class="literal"
>multi_array_ref</tt></h3>
</div>
</div>
</div>
<p><tt class="literal">multi_array_ref</tt> is a multi-dimensional container
adaptor.  It provides the MultiArray interface over any contiguous block of
elements.  <tt class="literal">multi_array_ref</tt> exports the same interface
as <tt class="literal">multi_array</tt>, with the exception of the
constructors.</p>
<p title="Model Of."><strong>Model Of.</strong></p>
<ul>
<li><a class="link" href="#MultiArray" title="MultiArray Concept"
><strong>MultiArray</strong></a></li>
<li><a class="ulink" href="../../../libs/utility/CopyConstructible.html"
target="_top"><strong>CopyConstructible</strong></a></li>
<li><a class="ulink" href=
"http://www.rrsd.com/software_development/stl/stl/EqualityComparable.html"
target="_top"><strong>EqualityComparable</strong></a> if the element type is
<a class="ulink" href=
"http://www.rrsd.com/software_development/stl/stl/EqualityComparable.html"
target="_top"><strong>EqualityComparable</strong></a></li>
<li><a class="ulink" href=
"http://www.rrsd.com/software_development/stl/stl/LessThanComparable.html"
target="_top"><strong>LessThanComparable</strong></a> if the element type is
<a class="ulink" href=
"http://www.rrsd.com/software_development/stl/stl/LessThanComparable.html"
target="_top"><strong>LessThanComparable</strong></a></li>
</ul>
<p>Detailed descriptions are provided here only for operations that are not
described in the <tt class="literal">multi_array</tt> reference.</p>
<p title="Synopsis"><strong>Synopsis.</strong></p>
<pre class="programlisting">
namespace boost {

    template &lt;typename ValueType, std::size_t NumDims&gt;
    class multi_array_ref
    {
     public:
        // types:
        typedef ValueType                             element;
        typedef *unspecified*                         value_type;
        typedef *unspecified*                         reference;
        typedef *unspecified*                         const_reference;
        typedef *unspecified*                         difference_type;
        typedef *unspecified*                         iterator;
        typedef *unspecified*                         const_iterator;
        typedef *unspecified*                         reverse_iterator;
        typedef *unspecified*                         const_reverse_iterator;
        typedef multi_array_types::size_type          size_type;
        typedef multi_array_types::index              index;
        typedef multi_array_types::index_gen          index_gen;
        typedef multi_array_types::index_range        index_range;
        typedef multi_array_types::extent_gen         extent_gen;
        typedef multi_array_types::extent_range       extent_range;
        typedef *unspecified*                         storage_order_type;

        // template typedefs
        template &lt;std::size_t Dims&gt; struct            subarray;
        template &lt;std::size_t Dims&gt; struct            const_subarray;
        template &lt;std::size_t Dims&gt; struct            array_view;
        template &lt;std::size_t Dims&gt; struct            const_array_view;

        static std::size_t const dimensionality = NumDims;

        // constructors and destructors

        template &lt;typename ExtentList&gt;
        multi_array_ref(
            element* data
          , ExtentList const&amp; sizes
          , storage_order_type const&amp; store = c_storage_order()
        );
        explicit multi_array_ref(
            element* data
          , extents_tuple const&amp; ranges
          , storage_order_type const&amp; store = c_storage_order()
        );
        multi_array_ref(multi_array_ref const&amp; x);
        ~multi_array_ref();

        // modifiers

        multi_array_ref&amp; operator=(multi_array_ref const&amp; x);
        template &lt;typename Array&gt;
        multi_array_ref&amp; operator=(Array const&amp; x);

        // iterators:
        iterator begin();
        iterator end();
        const_iterator begin() const;
        const_iterator end() const;
        reverse_iterator rbegin();
        reverse_iterator rend();
        const_reverse_iterator rbegin() const;
        const_reverse_iterator rend() const;

        // capacity:
        size_type size() const;
        size_type num_elements() const;
        size_type num_dimensions() const;

        // element access:
        template &lt;typename IndexList&gt; 
        element&amp; operator()(IndexList const&amp; indices);
        template &lt;typename IndexList&gt;
        element const&amp; operator()(IndexList const&amp; indices) const;
        reference operator[](index i);
        const_reference operator[](index i) const;
        array_view&lt;Dims&gt;::type operator[](indices_tuple const&amp; r);
        const_array_view&lt;Dims&gt;::type
            operator[](indices_tuple const&amp; r) const;

        // queries
        element* data();
        element const* data() const;
        element* origin();
        element const* origin() const;
        size_type const* shape() const;
        index const* strides() const;
        index const* index_bases() const;
        storage_order_type const&amp; storage_order() const;

        // comparators
        bool operator==(multi_array_ref const&amp; rhs);
        bool operator!=(multi_array_ref const&amp; rhs);
        bool operator&lt;(multi_array_ref const&amp; rhs);
        bool operator&gt;(multi_array_ref const&amp; rhs);
        bool operator&gt;=(multi_array_ref const&amp; rhs);
        bool operator&lt;=(multi_array_ref const&amp; rhs);

        // modifiers:
        template &lt;typename InputIterator&gt;
        void assign(InputIterator begin, InputIterator end);
        template &lt;typename SizeList&gt;
        void reshape(SizeList const&amp; sizes);
        template &lt;typename BaseList&gt;
        void reindex(BaseList const&amp; values);
        void reindex(index value);
    };
} // namespace boost
</pre>
<p title="Constructors"><strong>Constructors.</strong></p>
<div class="variablelist">
<dl>
<dt><span class="term"><pre class="programlisting">
    template &lt;typename ExtentList&gt;
    multi_array_ref(
        element* data
      , ExtentList const&amp; sizes
      , storage_order const&amp; store = c_storage_order()
      , Allocator const&amp; alloc = Allocator()
    );
</pre></span></dt>
<dd><p>This constructs a <tt class="literal">multi_array_ref</tt> using the
specified parameters.  <tt class="literal">sizes</tt> specifies the shape of
the constructed <tt class="literal">multi_array_ref</tt>.  <tt class="literal"
>store</tt> specifies the storage order or layout in memory of the array
dimensions.  <tt class="literal">alloc</tt> is used to
allocate the contained elements.</p>
<p title="ExtentList Requirements"><strong><tt class="literal">ExtentList</tt>
Requirements.</strong>  <tt class="literal">ExtentList</tt> must model
<a class="ulink" href="../../utility/Collection.html" target="_top"
><strong>Collection</strong></a>.</p>
<p title="Preconditions"><strong>Preconditions.</strong>  <tt class="literal"
>sizes.size() == NumDims;</tt></p></dd>
<dt><span class="term"><pre class="programlisting">
    multi_array_ref(
        element* data
      , extent_gen::gen_type&lt;NumDims&gt;::type ranges
      , storage_order const&amp; store = c_storage_order()
    );
</pre></span></dt>
<dd><p>This constructs a <tt class="literal">multi_array_ref</tt> using the
specified parameters.  <tt class="literal">ranges</tt> specifies the shape and
index bases of the constructed multi_array_ref.  It is the result of 
<tt class="literal">NumDims</tt> chained calls to <tt class="literal"
>extent_gen::operator[]</tt>.  <tt class="literal">store</tt> specifies the
storage order or layout in memory of the array dimensions.</p></dd>
<dt><span class="term"><pre class="programlisting">
    multi_array_ref(multi_array_ref const&amp; x);
</pre></span></dt>
<dd><p>This constructs a shallow copy of <tt class="literal">x</tt>.</p>
<p title="Complexity"><strong>Complexity.</strong>  Constant time (for
contrast, compare this to the <tt class="literal">multi_array</tt> class copy
constructor.
</p></dd>
</dl>
</div>
<p title="Modifiers"><strong>Modifiers.</strong></p>
<div class="variablelist">
<dl>
<dt><span class="term"><pre class="programlisting">
    multi_array_ref&amp; operator=(multi_array_ref const&amp; x);
    template &lt;typename Array&gt;
    multi_array_ref&amp; operator=(Array const&amp; x);
</pre></span></dt>
<dd><p>This performs an element-wise copy of <tt class="literal">x</tt> into
the current <tt class="literal">multi_array_ref</tt>.</p>
<p title="Array Requirements"><strong><tt class="literal">Array</tt>
Requirements.</strong>  <tt class="literal">Array</tt> must model
<strong>MultiArray</strong>.</p>
<p title="Preconditions"><strong>Preconditions.</strong></p>
<pre class="programlisting">
    std::equal(
        this-&gt;shape()
      , this-&gt;shape() + this-&gt;num_dimensions()
      , x.shape()
    );
</pre>
<p title="Postconditions"><strong>Postconditions.</strong></p>
<pre class="programlisting">(*.this) == x;</pre>
<p title="Complexity"><strong>Complexity.</strong>  The assignment operators
perform O(<tt class="literal">x.num_elements()</tt>) calls to
<tt class="literal">element</tt>'s copy constructor.</p></dd>
</dl>
</div>
</div>
<div class="sect2" title="const_multi_array_ref">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="const_multi_array_ref"></a><tt class="literal"
>const_multi_array_ref</tt></h3>
</div>
</div>
</div>
<p><tt class="literal">const_multi_array_ref</tt> is a multi-dimensional
container adaptor.  It provides the <strong>MultiArray</strong> interface over
any contiguous block of elements.  <tt class="literal"
>const_multi_array_ref</tt> exports the same interface as <tt class="literal"
>multi_array</tt>, with the exception of the constructors.</p>
<p title="Model Of."><strong>Model Of.</strong></p>
<ul>
<li><a class="link" href="#MultiArray" title="MultiArray Concept"
><strong>MultiArray</strong></a></li>
<li><a class="ulink" href="../../../libs/utility/CopyConstructible.html"
target="_top"><strong>CopyConstructible</strong></a></li>
<li><a class="ulink" href=
"http://www.rrsd.com/software_development/stl/stl/EqualityComparable.html"
target="_top"><strong>EqualityComparable</strong></a> if the element type is
<a class="ulink" href=
"http://www.rrsd.com/software_development/stl/stl/EqualityComparable.html"
target="_top"><strong>EqualityComparable</strong></a></li>
<li><a class="ulink" href=
"http://www.rrsd.com/software_development/stl/stl/LessThanComparable.html"
target="_top"><strong>LessThanComparable</strong></a> if the element type is
<a class="ulink" href=
"http://www.rrsd.com/software_development/stl/stl/LessThanComparable.html"
target="_top"><strong>LessThanComparable</strong></a></li>
</ul>
<p>Detailed descriptions are provided here only for operations that are not
described in the <tt class="literal">multi_array</tt> reference.</p>
<p title="Synopsis"><strong>Synopsis.</strong></p>
<pre class="programlisting">
namespace boost {

    template &lt;
        typename ValueType
      , std::size_t NumDims
      , typename TPtr = T const*
    &gt;
    class const_multi_array_ref
    {
     public:
        // types:
        typedef ValueType                             element;
        typedef *unspecified*                         value_type;
        typedef *unspecified*                         reference;
        typedef *unspecified*                         const_reference;
        typedef *unspecified*                         difference_type;
        typedef *unspecified*                         iterator;
        typedef *unspecified*                         const_iterator;
        typedef *unspecified*                         reverse_iterator;
        typedef *unspecified*                         const_reverse_iterator;
        typedef multi_array_types::size_type          size_type;
        typedef multi_array_types::index              index;
        typedef multi_array_types::index_gen          index_gen;
        typedef multi_array_types::index_range        index_range;
        typedef multi_array_types::extent_gen         extent_gen;
        typedef multi_array_types::extent_range       extent_range;
        typedef *unspecified*                         storage_order_type;

        // template typedefs
        template &lt;std::size_t Dims&gt; struct            subarray;
        template &lt;std::size_t Dims&gt; struct            const_subarray;
        template &lt;std::size_t Dims&gt; struct            array_view;
        template &lt;std::size_t Dims&gt; struct            const_array_view;

        // structors

        template &lt;typename ExtentList&gt;
        explicit const_multi_array_ref(
            TPtr data
          , ExtentList const&amp; sizes
          , storage_order_type const&amp; store = c_storage_order()
        );
        explicit const_multi_array_ref(
            TPtr data
          , extents_tuple const&amp; ranges
          , storage_order_type const&amp; store = c_storage_order()
        );
        const_multi_array_ref(const const_multi_array_ref &amp; x);
        ~const_multi_array_ref();

        // iterators:
        const_iterator begin() const;
        const_iterator end() const;
        const_reverse_iterator rbegin() const;
        const_reverse_iterator rend() const;

        // capacity:
        size_type size() const;
        size_type num_elements() const;
        size_type num_dimensions() const;

        // element access:
        template &lt;typename IndexList&gt;
        element const&amp; operator()(IndexList const&amp; indices) const;
        const_reference operator[](index i) const;
        const_array_view&lt;Dims&gt;::type
            operator[](indices_tuple const&amp; r) const;

        // queries
        element const* data() const;
        element const* origin() const;
        size_type const* shape() const;
        index const* strides() const;
        index const* index_bases() const;
        storage_order_type const&amp; storage_order() const;

        // comparators
        bool operator==(const_multi_array_ref const&amp; rhs);
        bool operator!=(const_multi_array_ref const&amp; rhs);
        bool operator&lt;(const_multi_array_ref const&amp; rhs);
        bool operator&gt;(const_multi_array_ref const&amp; rhs);
        bool operator&gt;=(const_multi_array_ref const&amp; rhs);
        bool operator&lt;=(const_multi_array_ref const&amp; rhs);

        // modifiers:
        template &lt;typename SizeList&gt;
        void reshape(SizeList const&amp; sizes);
        template &lt;typename BaseList&gt;
        void reindex(BaseList const&amp; values);
        void reindex(index value);
    };
} // namespace boost
</pre>
<p title="Constructors"><strong>Constructors.</strong></p>
<div class="variablelist">
<dl>
<dt><span class="term"><pre class="programlisting">
    template &lt;typename ExtentList&gt;
    const_multi_array_ref(
        TPtr data
      , ExtentList const&amp; sizes
      , storage_order const&amp; store = c_storage_order()
    );
</pre></span></dt>
<dd><p>This constructs a <tt class="literal">const_multi_array_ref</tt> using
the specified parameters.  <tt class="literal">sizes</tt> specifies the shape
of the constructed <tt class="literal">const_multi_array_ref</tt>.  <tt
class="literal">store</tt> specifies the storage order or layout in memory of
the array dimensions.</p>
<p title="ExtentList Requirements"><strong><tt class="literal">ExtentList</tt>
Requirements.</strong>  <tt class="literal">ExtentList</tt> must model
<a class="ulink" href="../../utility/Collection.html" target="_top"
><strong>Collection</strong></a>.</p>
<p title="Preconditions"><strong>Preconditions.</strong>  <tt class="literal"
>sizes.size() == NumDims;</tt></p></dd>
<dt><span class="term"><pre class="programlisting">
    const_multi_array_ref(
        TPtr data
      , extent_gen::gen_type&lt;NumDims&gt;::type ranges
      , storage_order const&amp; store = c_storage_order()
    );
</pre></span></dt>
<dd><p title="Effects"><strong>Effects.</strong>  This constructs a
<tt class="literal">const_multi_array_ref</tt> using the specified
parameters.  <tt class="literal">ranges</tt> specifies the shape and index
bases of the constructed <tt class="literal">const_multi_array_ref</tt>.  It
is the result of <tt class="literal">NumDims</tt> chained calls to 
<tt class="literal">extent_gen::operator[]</tt>.  <tt class="literal"
>store</tt> specifies the storage order or layout in memory of the array
dimensions.</p></dd>
<dt><span class="term"><pre class="programlisting">
    const_multi_array_ref(const_multi_array_ref const&amp; x);
</pre></span></dt>
<dd><p title="Effects"><strong>Effects.</strong>  This constructs a shallow
copy of <code class="literal">x</code>.</p></dd>
</dl>
</div>
</div>
</div>
<div class="sect1" title="Auxiliary Components">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="auxiliary"></a>Auxiliary
Components</h2>
</div>
</div>
</div>
<div class="sect2" title="multi_array_types">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="multi_array_types"></a><tt class="literal"
>multi_array_types</tt></h3>
</div>
</div>
</div>
<pre class="programlisting">
namespace multi_array_types {

    typedef *unspecified* index;
    typedef *unspecified* size_type;
    typedef *unspecified* difference_type;
    typedef *unspecified* index_range;
    typedef *unspecified* extent_range;
    typedef *unspecified* index_gen;
    typedef *unspecified* extent_gen;
}
</pre>
<p>Namespace <tt class="literal">multi_array_types</tt> defines types
associated with <tt class="literal">multi_array</tt>, <tt class="literal"
>multi_array_ref</tt>, and <tt class="literal">const_multi_array_ref</tt>
that are not dependent upon template parameters.  These types find common use
with all Boost.Multiarray components.  They are defined in a namespace from
which they can be accessed conveniently.  With the exception of
<tt class="literal">extent_gen</tt> and <tt class="literal">extent_range</tt>,
these types fulfill the roles of the same name required by <strong
>MultiArray</strong> and are described in its concept definition.  <tt
class="literal">extent_gen</tt> and <tt class="literal">extent_range</tt> are
described below.</p>
</div>
<div class="sect2" title="extent_range">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="extent_range"></a><tt class="classname"
>extent_range</tt></h3>
</div>
</div>
</div>
<p><tt class="classname">extent_range</tt> objects define half open
intervals.  They provide shape and index base information to <tt
class="literal">multi_array</tt>, <tt class="literal">multi_array_ref</tt>,
and <tt class="literal">const_multi_array_ref</tt> constructors.  <tt
class="classname">extent_range</tt>s are passed in aggregate to an array
constructor (see <tt class="classname">extent_gen</tt> for more details).</p>
<p title="Synopsis"><strong>Synopsis.</strong></p>
<pre class="programlisting">
    class extent_range
    {
     public:
        typedef multi_array_types::index      index;
        typedef multi_array_types::size_type  size_type;

        // Structors
        extent_range(index start, index finish);
        extent_range(index finish);
        ~extent_range();

        // Queries
        index start() const;
        index finish() const;
        size_type size() const;
    };
</pre>
<p title="Model Of"><strong>Model Of.</strong></p>
<ul>
<li><a class="ulink" href=
"http://www.rrsd.com/software_development/stl/stl/DefaultConstructible.html"
target="_top"><strong>DefaultConstructible</strong></a></li>
<li><a class="ulink" href="../../../libs/utility/CopyConstructible.html"
target="_top"><strong>CopyConstructible</strong></a></li>
</ul>
<p title="Methods and Types"><strong>Methods and Types.</strong></p>
<div class="variablelist">
<dl>
<dt><span class="term"><pre class="programlisting">
    extent_range(index start, index finish);
</pre></span></dt>
<dd><p>This constructor defines the half open interval
<tt class="literal">[start, finish)</tt>.  The expression
<tt class="literal">finish</tt> must be greater than
<tt class="literal">start</tt>.</p></dd>
<dt><span class="term"><pre class="programlisting">
    extent_range(index finish);
</pre></span></dt>
<dd><p>This constructor defines the half open interval
<tt class="literal">[0, finish)</tt>.  The value of
<tt class="literal">finish</tt> must be positive.</p></dd>
<dt><span class="term"><pre class="programlisting">
    index start() const;
</pre></span></dt>
<dd><p>This function returns the first index represented by the
range.</p></dd>
<dt><span class="term"><pre class="programlisting">
    index finish() const;
</pre></span></dt>
<dd><p>This function returns the upper boundary value of the half-open
interval.  Note that the range does not include this value.</p></dd>
<dt><span class="term"><pre class="programlisting">
    size_type size() const;
</pre></span></dt>
<dd><p>This function returns the size of the specified range.  It is
equivalent to <tt class="literal">finish() - start()</tt>.</p></dd>
</dl>
</div>
</div>
<div class="sect2" title="extent_gen">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="extent_gen"></a><tt class="classname"
>extent_gen</tt></h3>
</div>
</div>
</div>
<p>The <tt class="classname">extent_gen</tt> class defines an interface for
aggregating array shape and indexing information to be passed to a
<tt class="literal">multi_array</tt>, <tt class="literal"
>multi_array_ref</tt>, or <tt class="literal">const_multi_array_ref</tt>
constructor.  Its interface mimics the syntax used to declare built-in array
types in C++.  For example, while a 3-dimensional array of 
<tt class="classname">int</tt> values in C++ would be declared as:</p>
<pre class="programlisting">
    int A[3][4][5];
</pre>
<p>a similar <tt class="classname">multi_array</tt> would be declared:</p>
<pre class="programlisting">
    multi_array&lt;int,3&gt; A(extents[3][4][5]);
</pre>
<p title="Synopsis"><strong>Synopsis.</strong></p>
<pre class="programlisting">
    template &lt;std::size_t NumRanges&gt;
    class *implementation_defined*
    {
     public:
        typedef multi_array_types::index index;
        typedef multi_array_types::size_type size_type;

        template &lt;std::size_t NumRanges&gt; class gen_type;

        gen_type&lt;NumRanges+1&gt;::type
            operator[](range const&amp; a_range) const;
        gen_type&lt;NumRanges+1&gt;::type operator[](index idx) const;
    };

    typedef *implementation_defined*&lt;0&gt; extent_gen;
</pre>
<p title="Methods and Types"><strong>Methods and Types.</strong></p>
<div class="variablelist">
<dl>
<dt><span class="term"><pre class="programlisting">
    template gen_type&lt;Ranges&gt;::type
</pre></span></dt>
<dd><p>This type generator is used to specify the result of 
<tt class="literal">Ranges</tt> chained calls to
<tt class="literal">extent_gen::operator[].</tt>  The types
<tt class="classname">extent_gen</tt> and
<tt class="classname">gen_type&lt;0&gt;::type</tt> are the same.</p></dd>
<dt><span class="term"><pre class="programlisting">
    gen_type&lt;NumRanges+1&gt;::type
    operator[](extent_range const&amp; a_range) const;
</pre></span></dt>
<dd><p>This function returns a new object containing all previous
<tt class="classname">extent_range</tt> objects in addition to
<tt class="literal">a_range.</tt>  <tt class="classname">extent_range</tt>
objects are aggregated by chained calls to
<tt class="function">operator[]</tt>.</p></dd>
<dt><span class="term"><pre class="programlisting">
    gen_type&lt;NumRanges+1&gt;::type operator[](index idx) const;
</pre></span></dt>
<dd><p>This function returns a new object containing all previous
<tt class="classname">extent_range</tt> objects in addition to
<tt class="literal">extent_range(0, idx).</tt>  This function gives the array
constructors a similar syntax to traditional C multidimensional array
declaration.</p></dd>
</dl>
</div>
</div>
<div class="sect2" title="Global Objects">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="idp19487120"></a>Global Objects</h3>
</div>
</div>
</div>
<p>For syntactic convenience, Boost.MultiArray defines two global objects as
part of its interface.  These objects play the role of object generators;
expressions involving them create other objects of interest.</p>
<p>Under some circumstances, the two global objects may be considered
excessive overhead.  Their construction can be prevented by defining the
preprocessor symbol <tt class="literal">BOOST_MULTI_ARRAY_NO_GENERATORS</tt>
before including <tt class="filename">boost/multi_array.hpp</tt>.</p>
<div class="sect3" title="extents">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="extents"></a><tt class="literal">extents</tt></h4>
</div>
</div>
</div>
<pre class="programlisting">
namespace boost {

    multi_array_base::extent_gen extents;
}
</pre>
<p>Boost.MultiArray's array classes use the <tt class="literal">extents</tt>
global object to specify array shape during their construction.  For example,
a 3 by 3 by 3 <tt class="classname">multi_array</tt> is constructed as
follows:</p>
<pre class="programlisting">
    multi_array&lt;int,3&gt; A(extents[3][3][3]);
</pre>
<p>The same array could also be created by explicitly declaring an
<tt class="literal">extent_gen</tt> object locally, but the global object
makes this declaration unnecessary.</p>
</div>
<div class="sect3" title="indices">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="indices"></a><tt class="literal">indices</tt></h4>
</div>
</div>
</div>
<pre class="programlisting">
namespace boost {

    multi_array_base::index_gen indices;
}
</pre>
<p>The <strong>MultiArray</strong> concept specifies an <tt class="literal"
>index_gen</tt> associated type that is used to create views.  <tt
class="literal">indices</tt> is a global object that serves the role of
<tt class="literal">index_gen</tt> for all array components provided by this
library and their associated subarrays and views.</p>
<p>For example, using the <tt class="literal">indices</tt> object, a view of
an array <tt class="literal">A</tt> is constructed as follows:</p>
<pre class="programlisting">
    A[indices[index_range(0,5)][2][index_range(2,4)]];
</pre>
</div>
</div>
<div class="sect2" title="View and SubArray Generators">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="generators"></a>View and SubArray Generators</h3>
</div>
</div>
</div>
<p>Boost.MultiArray provides traits classes--<tt class="literal"
>subarray_gen</tt>, <tt class="literal">const_subarray_gen</tt>,
<tt class="literal">array_view_gen</tt>, and <tt class="literal"
>const_array_view_gen</tt>--for naming of array associated types within
function templates.  In general this is no more convenient to use than the
nested type generators, but the library author found that some C++ compilers
do not properly handle templates nested within function template parameter
types.  These generators constitute a workaround for this deficit.  The
following code snippet illustrates the correspondence between the
<tt class="literal">array_view_gen</tt> traits class and the
<tt class="literal">array_view</tt> type associated with an array:</p>
<pre class="programlisting">
    template &lt;typename Array&gt;
    void my_function()
    {
        typedef typename Array::template array_view&lt;3&gt;::type view1_t;
        typedef typename boost::array_view_gen&lt;Array,3&gt;::type view2_t;
        // ...
    }
</pre>
<p>In the above example, <tt class="literal">view1_t</tt> and
<tt class="literal">view2_t</tt> have the same type.</p>
</div>
<div class="sect2" title="Memory Layout Specifiers">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="memory_layout"></a>Memory Layout Specifiers</h3>
</div>
</div>
</div>
<p>While a multidimensional array represents a hierarchy of containers of
elements, at some point the elements must be laid out in memory.  As a result,
a single multidimensional array can be represented in memory more than one
way.</p>
<p>For example, consider the two dimensional array shown below in matrix
notation:</p>
<div><img src="matrix.gif" /></div>
<p>Here is how the above array is expressed in C++:</p>
<pre class="programlisting">
    int a[3][4] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
</pre>
<p>This is an example of row-major storage, where elements of each row
are stored contiguously.</p>
<p>While C++ transparently handles accessing elements of an array, you can
also manage the array and its indexing manually.  One way that this may be
expressed in memory is as follows:</p>
<pre class="programlisting">
    int a[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
    int s[] = { 4, 1 };
</pre>
<p>With the latter declaration of <tt class="literal">a</tt> and strides
<tt class="literal">s</tt>, element <tt class="literal">a(i, j)</tt> of the
array can be accessed using the expression</p>
<pre class="programlisting">
    *a + i * s[0] + j * s[1]
</pre>
<p>The same two dimensional array could be laid out by column as follows:</p>
<pre class="programlisting">
    int a[] = { 0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11 };
    int s[] = { 3, 1 };
</pre>
<p>Notice that the strides here are different.  As a result, the expression
given above to access values will work with this pair of data and strides as
well.</p>
<p>In addition to dimension order, it is also possible to store any dimension
in descending order.  For example, returning to the first example, the first
dimension of the example array, the rows, could be stored in reverse,
resulting in the following:</p>
<pre class="programlisting">
    int data[] = { 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3 };
    int* a = data + 8;
    int s[] = { -4, 1 };
</pre>
<p>Note that in this example <tt class="literal">a</tt> must be explicitly set
to the origin.  In the previous examples, the first element stored in memory
was the origin; here, this is no longer the case.</p>
<p>Alternatively, the second dimension, or the columns, could be reversed and
the rows stored in ascending order:</p>
<pre class="programlisting">
    int data[] = { 3, 2, 1, 0, 7, 6, 5, 4, 11, 10, 9, 8 };
    int* a = data + 3;
    int s[] = { 4, -1 };
</pre>
<p>Finally, both dimensions could be stored in descending order:</p>
<pre class="programlisting">
    int data[] = {11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
    int* a = data + 11;
    int s[] = { -4, -1 };
</pre>
<p>All of the above arrays are equivalent.  The expression given above for
<tt class="literal">a(i, j)</tt> will yield the same value regardless of the
memory layout.</p>
<p>Boost.MultiArray arrays can be created with customized storage parameters
as described above. Thus, existing data can be adapted (with <tt
class="literal">multi_array_ref</tt> or <tt class="literal"
>const_multi_array_ref</tt>) as suited to the array abstraction.  A common
usage of this feature would be to wrap arrays that must interoperate with
Fortran routines so they can be manipulated naturally at both the C++ and
Fortran levels.  The following sections describe the Boost.MultiArray
components used to specify memory layout.</p>
<div class="sect3" title="c_storage_order">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="c_storage_order"></a><tt class="literal"
>c_storage_order</tt></h4>
</div>
</div>
</div>
<pre class="programlisting">
    class c_storage_order
    {
        c_storage_order();
    };
</pre>
<p><tt class="literal">c_storage_order</tt> is used to specify that an array
should store its elements using the same layout as that used by primitive C++
multidimensional arrays, that is, from last dimension to first.  This is the
default storage order for the arrays provided by this library.</p>
</div>
<div class="sect3" title="fortran_storage_order">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="fortran_storage_order"></a><tt class="literal"
>fortran_storage_order</tt></h4>
</div>
</div>
</div>
<pre class="programlisting">
    class fortran_storage_order
    {
        fortran_storage_order();
    };
</pre>
<p><tt class="literal">fortran_storage_order</tt> is used to specify that an
array should store its elements using the same memory layout as a Fortran
multidimensional array would, that is, from first dimension to last.</p>
</div>
<div class="sect3" title="general_storage_order">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="general_storage_order"></a><tt class="literal"
>general_storage_order</tt></h4>
</div>
</div>
</div>
<pre class="programlisting">
    template &lt;std::size_t NumDims&gt;
    class general_storage_order
    {
        template &lt;typename OrderingIter, typename AscendingIter&gt;
        general_storage_order(OrderingIter ordering, AscendingIter ascending);
    };
</pre>
<p><tt class="literal">general_storage_order</tt> allows the user to specify
an arbitrary memory layout for the contents of an array.  The constructed
object is passed to the array constructor in order to specify storage
order.</p>
<p><tt class="literal">OrderingIter</tt> and <tt class="literal"
>AscendingIter</tt> must model the <tt class="literal">InputIterator</tt>
concept.  Both iterators must refer to a range of <tt class="literal"
>NumDims</tt> elements.  <tt class="literal">AscendingIter</tt> points to
objects convertible to <tt class="literal">bool</tt>.  A value of
<tt class="literal">true</tt> means that a dimension is stored in ascending
order while <tt class="literal">false</tt> means that a dimension is stored in
descending order.  <tt class="literal">OrderingIter</tt> specifies the order
in which dimensions are stored.</p>
</div>
</div>
<div class="sect2" title="Range Checking">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="range_checking"></a>Range Checking</h3>
</div>
</div>
</div>
<p>By default, the array access methods <tt class="literal">operator()</tt>
and <tt class="literal">operator[]</tt> perform range checking.  If a supplied
index is out of the range defined for an array, an assertion will abort the
program.  To disable range checking (for performance reasons in production
releases), define the <tt class="literal">BOOST_DISABLE_ASSERTS</tt>
preprocessor macro prior to including
<tt class="filename">boost/multi_array.hpp</tt> in an application.</p>
</div>
</div>
</div>
</body>
</html>

